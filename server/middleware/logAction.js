// middleware/logAction.js - ENHANCED RICH VERSION
import Log from '../models/Log.js';
import Notification from '../models/Notification.js';
import User from '../models/User.js'; // Make sure to import User model

export const logAction = (action, resourceType) => {
  return async (req, res, next) => {
    // Store the original function to call after response
    const originalSend = res.send;
    
    res.send = function(data) {
      // Only log successful responses (2xx status codes)
      if (res.statusCode >= 200 && res.statusCode < 300) {
        // Log the action asynchronously without blocking the response
        Log.create({
          userId: req.user?._id || 'system', // Fallback to 'system' if no user
          userName: req.user?.name || 'System',
          userEmail: req.user?.email || 'system@lfc.com',
          action,
          resource: resourceType,
          details: `${action} ${resourceType}`,
          resourceId: req.params.courseId || req.params.id || req.body._id,
          ipAddress: req.ip,
          userAgent: req.get('User-Agent'),
          status: 'success',
          timestamp: new Date()
        }).then(async (log) => {
          // AUTO-CREATE NOTIFICATIONS BASED ON ACTION TYPE
          await createNotificationFromLog(log, req);
        }).catch(error => {
          console.error('Failed to log action:', error);
          // Don't throw - logging failure shouldn't break the app
        });
      }
      
      // Call the original send function
      return originalSend.call(this, data);
    };
    
    next();
  };
};

const createNotificationFromLog = async (log, req) => {
  try {
    let notificationData = {};
    
    switch (log.action) {
      case 'enroll':
        notificationData = {
          userId: log.userId,
          title: `Enrolled in new course`,
          message: `You have been enrolled in a new course`,
          type: 'course',
          link: `/courses/${log.resourceId}`,
          autoGenerated: true,
          timestamp: new Date()
        };
        break;
        
      case 'submit':
        notificationData = {
          userId: log.userId,
          title: `Submission received`,
          message: `Your assignment submission has been received`,
          type: 'submission',
          link: `/admin/submissions/${log.resourceId}`,
          autoGenerated: true,
          timestamp: new Date()
        };
        break;
        
      case 'grade':
        // Notify student about grade
        notificationData = {
          userId: log.details?.studentId || req.body?.studentId, // Multiple fallbacks
          title: `Assignment graded`,
          message: `Your assignment has been graded`,
          type: 'grade',
          link: `/courses/${log.details?.courseId || req.body?.courseId}/assignments/${log.resourceId}`,
          autoGenerated: true,
          timestamp: new Date()
        };
        break;
        
      case 'create':
        if (log.resource === 'course') {
          // Notify all admins about new course
          const admins = await User.find({ role: { $in: ['admin', 'admin-only'] } }).select('_id');
          const notificationPromises = admins.map(admin => 
            Notification.create({
              userId: admin._id,
              title: `New course created`,
              message: `New course: ${log.details?.title || req.body?.title || 'Untitled'}`,
              type: 'course',
              link: `/admin/courses/${log.resourceId}`,
              autoGenerated: true,
              timestamp: new Date()
            })
          );
          await Promise.all(notificationPromises);
          return; // Early return for bulk notifications
        }
        break;
        
      case 'update':
        notificationData = {
          userId: log.userId,
          title: `${log.resource} updated`,
          message: `Your ${log.resource} has been updated`,
          type: log.resource,
          link: `/${log.resource}s/${log.resourceId}`,
          autoGenerated: true,
          timestamp: new Date()
        };
        break;
        
      case 'delete':
        notificationData = {
          userId: log.userId,
          title: `${log.resource} deleted`,
          message: `Your ${log.resource} has been deleted`,
          type: 'system',
          autoGenerated: true,
          timestamp: new Date()
        };
        break;
        
      default:
        return; // No notification for this action
    }

    if (notificationData.userId && notificationData.userId !== 'system') {
      await Notification.create(notificationData);
    }
    
  } catch (error) {
    console.error('Auto-notification creation failed:', error);
    // Don't throw - notification failure shouldn't break logging
  }
};

// Additional helper middleware for specific common actions
export const logWithDetails = (action, resourceType, customDetails) => {
  return async (req, res, next) => {
    const originalSend = res.send;
    
    res.send = function(data) {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        Log.create({
          userId: req.user?._id || 'system',
          userName: req.user?.name || 'System',
          userEmail: req.user?.email || 'system@lfc.com',
          action,
          resource: resourceType,
          details: customDetails || `${action} ${resourceType}`,
          resourceId: req.params.courseId || req.params.id || req.body._id,
          ipAddress: req.ip,
          userAgent: req.get('User-Agent'),
          status: 'success',
          timestamp: new Date(),
          additionalData: req.body // Include full request body for detailed logging
        }).then(async (log) => {
          await createNotificationFromLog(log, req);
        }).catch(error => {
          console.error('Failed to log action:', error);
        });
      }
      
      return originalSend.call(this, data);
    };
    
    next();
  };
};