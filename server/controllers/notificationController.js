// controllers/notificationController.js - UPDATED
import Notification from "../models/Notification.js";
import Log from "../models/Log.js";

// Create MANUAL notification (admin custom messages only)
export const createManualNotification = async (req, res) => {
  try {
    const { userIds, title, message, type = 'info', link } = req.body;

    if (!userIds || !title) {
      return res.status(400).json({ 
        message: "User IDs and title are required" 
      });
    }

    const notifications = [];
    const userIdArray = Array.isArray(userIds) ? userIds : [userIds];

    for (const userId of userIdArray) {
      const notification = await Notification.create({
        userId,
        title,
        message,
        type,
        link,
        manual: true, // Mark as manual notification
        createdBy: req.user._id
      });
      notifications.push(notification);
    }

    res.status(201).json({
      message: `Notification sent to ${notifications.length} user(s)`,
      notifications
    });
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
};

// Get notifications with advanced filtering
export const getMyNotifications = async (req, res) => {
  try {
    const { 
      type, 
      read, 
      source, 
      dateFrom, 
      dateTo, 
      page = 1, 
      limit = 20 
    } = req.query;

    const filter = { user: req.user._id };
    
    // Filter by type
    if (type && type !== 'all') {
      filter.type = type;
    }
    
    // Filter by read status
    if (read !== undefined) {
      filter.read = read === 'true';
    }
    
    // Filter by source (manual vs auto)
    if (source === 'manual') {
      filter.manual = true;
    } else if (source === 'auto') {
      filter.autoGenerated = true;
    }
    
    // Filter by date range
    if (dateFrom || dateTo) {
      filter.createdAt = {};
      if (dateFrom) filter.createdAt.$gte = new Date(dateFrom);
      if (dateTo) filter.createdAt.$lte = new Date(dateTo);
    }

    const notifications = await Notification.find(filter)
      .sort({ createdAt: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .populate('createdBy', 'name'); // Populate admin who created manual notifications

    const total = await Notification.countDocuments(filter);

    // Get unread count for badge
    const unreadCount = await Notification.countDocuments({
      user: req.user._id,
      read: false
    });

    res.json({
      notifications,
      totalPages: Math.ceil(total / limit),
      currentPage: parseInt(page),
      total,
      unreadCount
    });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Get available filters for notifications
export const getNotificationFilters = async (req, res) => {
  try {
    const userId = req.user._id;
    
    const filters = {
      types: await Notification.distinct('type', { user: userId }),
      sources: ['all', 'manual', 'auto'],
      dateRange: {
        minDate: await Notification.findOne({ user: userId }).sort({ createdAt: 1 }).select('createdAt'),
        maxDate: await Notification.findOne({ user: userId }).sort({ createdAt: -1 }).select('createdAt')
      }
    };

    res.json(filters);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Create a notification (admin only) - THIS IS YOUR WORKING ROUTE
export const createNotification = async (req, res) => {
  try {
    const { userId, title, type, link, dueDate } = req.body;

    const notification = await createNotificationForUser({
      userId,
      title,
      type,
      link,
      dueDate,
    });

    res.status(201).json(notification);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
};

// Mark a single notification as read
export const markAsRead = async (req, res) => {
  try {
    await Notification.findByIdAndUpdate(req.params.notificationId, { read: true });
    res.json({ message: "Marked as read" });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Mark all notifications as read
export const markAllAsRead = async (req, res) => {
  try {
    await Notification.updateMany({ user: req.user._id }, { read: true });
    res.json({ message: "All marked as read" });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Delete a notification
export const deleteNotification = async (req, res) => {
  try {
    await Notification.findByIdAndDelete(req.params.notificationId);
    res.json({ message: "Deleted successfully" });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

// Utility function to call the working POST route
export const callCreateNotification = async (notificationData) => {
  try {
    // Create a mock request object that matches your POST route signature
    const mockReq = {
      body: notificationData
    };
    
    const mockRes = {
      status: (code) => ({
        json: (data) => {
          if (code >= 400) {
            throw new Error(data.message || 'Notification creation failed');
          }
          return data;
        }
      })
    };

    // Call the createNotification function directly
    await createNotification(mockReq, mockRes);
    console.log('✅ Notification created via POST route:', notificationData.title);
    
  } catch (error) {
    console.error('❌ Failed to create notification via POST route:', error.message);
    // Don't throw - we don't want to break the main operation
  }
};

// Delete ALL notifications (kill switch - admin only + confirm)
export const deleteAllNotifications = async (req, res) => {
  try {
    if (req.query.confirm !== "true") {
      return res.status(400).json({
        message: "Confirmation required. Add ?confirm=true to proceed.",
      });
    }

    await Notification.deleteMany({});
    res.json({ message: "⚠️ All notifications have been permanently deleted." });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

